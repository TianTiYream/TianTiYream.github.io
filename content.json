{"pages":[{"title":"categories","text":"","link":"/TianTiYream.github.io/categories/index.html"},{"title":"tags","text":"","link":"/TianTiYream.github.io/tags/index.html"}],"posts":[{"title":"Vue中的mixin","text":"使用mixin的原因 代码复用 项目的共享文件 减少耦合 mixin的用法 正常vue文件的结构，但以.js为后缀 在需要使用的文件中使用时，import share from @/mixins/share.js，然后在vue文件的data同级加上mixins: [share,mixin2,...]，引入后即可使用share.js中的所有方法 有时见到import {} from ...的用法，使用{}时，相应js文件中用export导出，不使用{}用export default导出 mixin的原理 本质是js文件 vue内部做了处理，使其具有生命周期函数、computed等功能，方便数据传输","link":"/TianTiYream.github.io/2019/12/05/Vue%E4%B8%AD%E7%9A%84mixin/"},{"title":"js事件循环","text":"Js事件循环 过程： 单线程，先依次执行栈中的函数，遇到异步操作时，判断是宏任务还是微任务 如果是宏任务存入宏任务队列，微任务存入微任务队列 主线执行完后，先判断微任务队列里是否有任务，没有的话再去看宏任务队列里是否有任务 每次一个宏任务结束后去查看微任务队列，如果微任务队列有多个任务，需要等执行完所有的微任务后再去执行下一个宏任务 简易过程：宏任务(主线代码) -&gt; 微任务,微任务,微任务… -&gt; 宏任务 -&gt; 微任务,微任务,微任务… -&gt; 宏任务 … 宏任务： setTimeout setInterval I/O操作 微任务： Promise MutationObserver","link":"/TianTiYream.github.io/2020/06/15/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"title":"JavaScript原型链","text":"原型链图解 Object.prototype","link":"/TianTiYream.github.io/2020/06/10/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"title":"hexo搭建博客遇到的一些问题","text":"hexo搭建博客遇到的一些问题 _config.yml里的url和root12url: http://tiantiyream.github.io/TianTiYream.github.io #部署的网站名+github的项目名root: /TianTiYream.github.io/ #github的项目名 基本发布流程1234hexo g #生成静态文件hexo s #本地预览hexo d #部署到远程hexo d -g #生成并发布简写形式 文章操作流程1234hexo new \"文章标题\" #新建一篇文章#打开_source文件夹下新建的文章，用md编辑器编辑#保存文章，进行上面的基本发布流程操作#删除文章可在本地删除后再进行发布流程操作 添加萌宠12npm install hexo-helper-live2d --save #安装插件npm install live2d-widget-model-tororo #白猫模型 123456789101112131415161718# 右下角动画模型live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: # 这是白猫的模型 use: live2d-widget-model-tororo display: # 设置模型的位置 position: right mobile: show: false react: opacityDefault: 1 opacityOnHover: 1","link":"/TianTiYream.github.io/2019/09/26/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"},{"title":"nodeJs 模块","text":"CommonJS规范在一个js文件中输出module export variable,在另一个js文件中引入var varible = require('module varible') 规范出现原因大量js文件相同全局变量或方法等易造成冲突 全局污染的历史解决方法： 匿名函数1234(function greet() {})()// 原理：","link":"/TianTiYream.github.io/2019/11/08/nodeJs-%E6%A8%A1%E5%9D%97/"},{"title":"node脚本定期清除微信文件","text":"node脚本清除微信文件（只保留近三个月的文件，自己使用，时间暂不考虑跨年） 123456789101112131415161718192021222324252627282930const fs = require('fs')const f_path = 'E:/WeChat Files/wxid_s148s7uxj46m22/FileStorage/File'delFile(f_path)// 递归调用function delFile (curPath) { let nowYear = new Date().getFullYear() let nowMonth = new Date().getMonth() let files = fs.readdirSync(curPath) files.map (function (item) { // 判断文件日期是否大于3个月，return跳出本次循环 if (curPath === f_path &amp;&amp; !(item.split('-')[0] &lt; nowYear || nowMonth - item.split('-')[1] &gt;= 2)) { return } if (fs.existsSync(curPath)) { let curPath1 = curPath + '/' + item // 判断是否是文件夹 if (fs.statSync(curPath1).isDirectory()) { delFile(curPath1) } else { fs.unlinkSync(curPath1) } } }) // 防止死锁 if (curPath !== f_path) { fs.rmdirSync(curPath) }}","link":"/TianTiYream.github.io/2020/07/14/node%E8%84%9A%E6%9C%AC%E5%AE%9A%E6%9C%9F%E6%B8%85%E9%99%A4%E5%BE%AE%E4%BF%A1%E6%96%87%E4%BB%B6/"},{"title":"react初学安装","text":"方法一：引入CDN123456789101112&lt;script src=\"https://unpkg.com/react@16/umd/react.development.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"&gt;&lt;/script&gt; &lt;!-- 生产环境中不建议使用 --&gt; &lt;script src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/jsx\"&gt; const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; ReactDOM.render( element, document.getElementById('app') ) &lt;/script&gt; 方法二：npm npm install -g create-react-app create-react-app 项目名","link":"/TianTiYream.github.io/2019/10/08/react%E5%88%9D%E5%AD%A6%E5%AE%89%E8%A3%85/"},{"title":"Vue响应式原理","text":"初步理解1234567891011121314151617181920212223242526272829303132333435const obj = { name: 'xiaoli', age: 12, sex: 'male'}// 对obj的每个属性做响应式处理for (let key in obj) { reactive(obj, key, obj[key])}// 响应式处理函数function reactive(obj, key, val) { Object.defineProperty(obj, key, { get: function () { const value = val // watcher() 通知对view层渲染 console.log(key + ' view 渲染 ' + value) return value }, set: function (newValue) { val = newValue // watcher() 通知对view层更新 console.log(key + ' view 更新 ' + val) } })}// 测试obj.name = 'xiaohong'obj.sex = 'female'console.log(obj.name, 'name', obj.sex, 'sex')// 模拟没有在data中初始化的属性，没有做响应式处理，watcher不会通知更新和渲染obj.hobby = 'play'console.log(obj.hobby, 'hobby') 进阶理解1234567891011121314151617181920212223242526272829303132333435363738// 发布/订阅模式// 将数据data变成可观察的function observer (obj, cb) { Object.keys(obj).forEach((key) =&gt; defineReactive(obj, key, obj[key], cb))}function defineReactive(obj, key, val, cb) { Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: () =&gt; { // 依赖收集等 return val }, set: newVal =&gt; { val = newVal cb() // 订阅者收到消息的回调 } })}class Vue { constructor(options) { this._data = options.data observer(this._data, options.render) }}let app = new Value({ el: '#app', data: { text: 'text', text2: 'text2' }, render() { console.log('render') }})","link":"/TianTiYream.github.io/2020/07/27/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"},{"title":"windows系统常用快捷键总结","text":"返回上一级文件 backspace谷歌浏览器切换tab ctrl+tab切换弹框 alt+tab谷歌浏览器新建tab ctrl+t谷歌浏览器撤销 ctrl+shift+t谷歌打开第N个tab ctrl+N(N=1,2,3…)谷歌浏览器前进/后退 alt+-&gt;/alt+&lt;-关闭所有tab alt+f4关闭当前tab ctrl+f4","link":"/TianTiYream.github.io/2019/10/16/windows%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93/"},{"title":"使用fiddler遇到的问题","text":"不能捕获到localhost的请求 解决：在fiddler options里将enable ipv6前面的对勾去掉 不能捕获到谷歌浏览器的请求 解决：谷歌浏览器使用了谷歌访问助手代理插件，关闭即可正常捕获","link":"/TianTiYream.github.io/2020/06/17/%E4%BD%BF%E7%94%A8fiddler%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"vuex学习总结","text":"state 注册store123456789const app = new Vue({ el: '#app', store, template: ` &lt;div class='app&gt; counter &lt;/div&gt; `}) 注册后的组件可使用this.$store获取12345const Counter = { count () { return this.$store.state.count }} 获取多个状态123456789computed: { mapState({ count: state =&gt; state.count, countAlias: 'count', countPlusLocal ( state ) { return state.count + this.localCount } })} 当计算属性的名称与store中的属性相同时可使用字符串数组123456computed: { mapState([ // 相当于 this.count =&gt; state.count 'count' ])} 多个store属性与局部属性混合使用1234567891011const Counter = { computed: { localCount () { return this.count }, // 扩展运算符 ...mapState({ // ... }) }} getter getter: state派生状态 getter定义12345678910111213141516171819202122const store = new Vuex.Store({ state: { todos: [ {id: '1', text: '...', done: true}, {id: '2', text: '...', done: false} ] }, getters: { // 1.1 属性定义 doneTodos: (state) =&gt; { return state.todos.filter(todo =&gt; todo.done) }, // 1.2 可传入其他getter做为第二个参数 doneTodosCount: (state, getters) =&gt; { return getters.doneTodos.length }, // 1.3 可用方法定义 getTodosById: (state) =&gt; (id) =&gt; { return state.todos.find(todo =&gt; todo.id === id) } }}) 访问123456// 2.1 属性访问store.getters.doneTodos // [{id: '1', text: '...', done: true}]store.getters.doneTodosCount // 1// 2.2 方法访问// 方法访问时不会缓存结果，每次都重新调用store.getters.getTodosById('2') // {id: '2', text: '...', done: false} mapGetters获取多个getter123456789101112import { mapGetters } from 'vuex'export default { computed: { ...mapGetters(['doneTodos', 'doneTodosCount']) // 3.1 将getters映射到局部计算属性，属性名相同 }, computed: { ...mapGetters({ count: 'doneTodosCount' // 3.2 如果用不同的局部属性名称需要使用对象形式 }) }} mutation mutation是唯一改变store中state的方法 定义 12345678910111213141516171819const store = new Vuex.Store({ state: { count: 0 }, mutations: { // 1.1 没有载荷 increment (state) { state.count ++ }, // 1.2 有载荷 incrementBy (state, n) { state.count += n }, // 1.3 有载荷payload并且是对象 incrementByObj (state, payload) { state.count += payload.amount } }}) 提交 12345678910111213// 2.1 没有载荷，触发increment事件类型store.commit('increment')// 2.2 有载荷store.commit('incrementBy', 10)// 2.3 有载荷，并使用对象方便传入多个属性store.commit('incrementByObj', { amount: 10})// 2.4 对象风格 事件类型写入对象store.commit({ type: 'incrementByObj', // type为事件类型 amount: 10}) mutations必须是同步函数 1// 同步函数可以保证调试时devtools可以看到store中每个时刻的state，异步函数则无法追踪状态的改变 mapMutations 简化代码，方便引入多个mutation 1234567891011121314import { mapMutations } from 'vuex'export default { methods: { ...mapMutations([ 'increment', // 将this.increment()映射为this.$store.commit('increment') 'incrementBy', // 将this.incrementBy()映射为this.$store.commit('incrementBy') 'incrementByObj' // 将this.incrementByObj映射为this.$store.commit('incrementByObj') ]), ...mapMutations({ add: 'increment' // 将this.add()映射this.$store.commit('increment') }) }} mutations遵循Vue的响应式原理 12// 5.1 store中先初始化所有属性// 5.2 若对象中需要新增属性，可使用Vue.set(obj, 'newProp', 123)或者this.state = {...this.state, newProp: 123} 使用常量替代事件类型 使linter类工具发挥作用 代码结构更加清晰 123456789101112131415// mutation-types.jsexport const SOME_MUTATIONS = 'SOME_MUTATIONS'// store.jsimport { SOME_MUTATIONS } from './mutation-types'const store = new Vuex.Store({ state: { // ... }, mutations: { [SOME_MUTATIONS] (state) { // state mutate } }})","link":"/TianTiYream.github.io/2020/06/28/vuex%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"title":"搭建Vue项目","text":"安装vue脚手架 npm install vue-cli -g 创建vue项目 vue init webpack 项目名 根据需要选择Y或N，一般会选择安装vue-router，不安装测试相关，依赖包可手动安装 npm run dev启动项目 常见问题 安装依赖包失败，卡住等，可清除后重新安装或者使用yarn npm cache clean -f 清缓存 npm install 或 yarn install","link":"/TianTiYream.github.io/2020/01/14/%E6%90%AD%E5%BB%BAvue%E9%A1%B9%E7%9B%AE/"},{"title":"正向代理和反向代理","text":"正向代理与反向代理 正向代理正向代理应用场景有访问外国网站等 在客户端与目的服务器之间有一个代理服务器，客户端无法直接访问目的服务器，代理服务器可以直接访问目的服务器 所以客户端发送请求给代理服务器，服务器再转发给目的服务器，得到目的服务器的响应后，再转发回客户端 目的服务器并不知道真正的请求数据的是哪个客户端 反向代理反向代理应用场景有浏览器跨域请求 同样在客户端与目的服务器之间有一个代理服务器，客户端无法直接访问目的服务器，代理服务器可以直接访问目的服务器 客户端发送请求给代理服务器，对于客户端来说，代理服务器就是它的目的服务器。然后代理服务器转发请求给真正的服务器，拿到响应后返回给客户端。 在此过程中客户端一直访问的都是一个固定的服务器（即代理服务器），并不知道真正响应的是哪个服务器 简单总结正向代理：代理的是客户端 反向代理：代理的是服务器 以Vue请求后台服务为例： proxyTable表里配置，’/api’是以’/api/XXX’的请求路径会发送到反向代理服务器，target为前端服务器地址，是否跨域为true，在代理服务器转发请求时会删除请求路径中的’/api’ 反向代理服务器由于和前端服务器同源，所以可以与浏览器进行数据交互","link":"/TianTiYream.github.io/2020/08/21/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"}],"tags":[{"name":"Vue","slug":"Vue","link":"/TianTiYream.github.io/tags/Vue/"},{"name":"JavaScript","slug":"JavaScript","link":"/TianTiYream.github.io/tags/JavaScript/"},{"name":"hexo","slug":"hexo","link":"/TianTiYream.github.io/tags/hexo/"},{"name":"nodeJs","slug":"nodeJs","link":"/TianTiYream.github.io/tags/nodeJs/"},{"name":"react","slug":"react","link":"/TianTiYream.github.io/tags/react/"},{"name":"windows","slug":"windows","link":"/TianTiYream.github.io/tags/windows/"},{"name":"网络","slug":"网络","link":"/TianTiYream.github.io/tags/%E7%BD%91%E7%BB%9C/"}],"categories":[{"name":"Vue","slug":"Vue","link":"/TianTiYream.github.io/categories/Vue/"},{"name":"JavaScript","slug":"JavaScript","link":"/TianTiYream.github.io/categories/JavaScript/"},{"name":"其它","slug":"其它","link":"/TianTiYream.github.io/categories/%E5%85%B6%E5%AE%83/"},{"name":"nodeJs","slug":"nodeJs","link":"/TianTiYream.github.io/categories/nodeJs/"},{"name":"React","slug":"React","link":"/TianTiYream.github.io/categories/React/"},{"name":"windows","slug":"windows","link":"/TianTiYream.github.io/categories/windows/"},{"name":"网络","slug":"网络","link":"/TianTiYream.github.io/categories/%E7%BD%91%E7%BB%9C/"}]}